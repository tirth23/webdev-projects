<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <!-- <button onclick="expensiveCalculation(event, 'Hello', 'World')">Click Me</button> -->

  <button onclick="throttledCallAPI(event, 'Hello', 'World')">Click Me</button>

  <script>
    /* used for resize, scroll, and other events that fire multiple times, where we need to
    throttle event i.e., only call the function after a certain amount of time has passed */


    let counter = 0;
    function expensiveCalculation(arr) {
      //calls an API and gets data
      console.log("Fetching data...", counter++, this.name, arr);
    }
    const throttle = (func, limit) => {
      let flag = true;
      return function () {
        let context = this;
        let args = arguments;
        if (flag) {
          func.apply(context, args);
          flag = false;
          setTimeout(() => flag = true, limit);
        }
      }
    }
    /* if difference between two func call is more than 300 milliseconds, then only call the function */
    /* call the function after 500 milliseconds even if the user clicks more than once */
    const throttledCallAPI = throttle(expensiveCalculation, 500);


    // let counter = 0;
    // function expensiveCalculation(arr) {
    //   //calls an API and gets data
    //   console.log("Fetching data...", counter++, this.name, arr);
    // }
    // const throttle = (func, limit) => {
    //   let timerId = null;
    //   return function () {
    //     if(timerId) return;
    //     timerId = setTimeout(() => {
    //       func.apply(this, arguments);
    //       timerId = null;
    //     }, limit);
    //   }
    // }
    // /* call the function after 500 milliseconds even if the user clicks more than once */
    // const throttledCallAPI = throttle(expensiveCalculation, 500);


    // /* With this binding */
    // let counter = 0;
    // function getData(arr) {
    //   //calls an API and gets data
    //   console.log("Fetching data...", counter++, this.name, arr);
    // }
    // const debounceObj = {
    //   name: 'name from debounceObj',
    //   debounce: function (func, delay) {
    //     let timer;
    //     console.log(this);
    //     return () => {
    //       /* In arrow function this will be the this of outer lexical scope  */
    //       let context = this;
    //       console.log(context);
    //       let args = arguments;
    //       clearTimeout(timer);
    //       timer = setTimeout(() => {
    //         /* here we had this binding so in apply() this will be the context of the function */
    //         func.apply(context, args);
    //         /* Here we don't have this binding so in apply() this will be the window object */
    //         // func(args);
    //       }, delay);
    //     }
    //   }
    // }
    // // if difference between two keystrokes is more than 300 milliseconds, then only call the function
    // const debouncedCallAPI = debounceObj.debounce(getData, 300);


    // /* Modern approach without this binding */
    // let counter = 0;
    // const getData = (e, arr) => {
    //   console.log("Fetching data...", counter++, arr, e.target.value);
    // };
    // const debounce = (func, delay) => {
    //   let timer;
    //   return (...args) => {
    //     clearTimeout(timer);
    //     timer = setTimeout(() => {
    //       func(...args);
    //     }, delay);
    //   }
    // }
    // const debouncedCallAPI = debounce(getData, 300);


    // /* Modern approach with this binding */
    // let counter = 0;
    // function getData(...arr) {
    //   console.log("Fetching data...", counter++, this.name, arr);
    // }
    // const debounceObj = {
    //   name: 'name from debounceObj',
    //   debounce: function (func, delay) {
    //     let timer;
    //     return (...args) => {
    //       let context = this;
    //       clearTimeout(timer);
    //       timer = setTimeout(() => {
    //         func.apply(context, args);
    //       }, delay);
    //     }
    //   }
    // }
    // const debouncedCallAPI = debounceObj.debounce(getData, 300);


  </script>
</body>

</html>